name: AI Auto Response (Gemini)

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

jobs:
  ai-response:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Gemini AI Response
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        ISSUE_NUMBER: ${{ github.event.issue.number }}
        ISSUE_TITLE: ${{ github.event.issue.title }}
        ISSUE_BODY: ${{ github.event.issue.body }}
        ISSUE_LABELS: ${{ join(github.event.issue.labels.*.name, ',') }}
      run: |
        # Gemini CLI ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
        npm install -g @google/gemini-cli
        
        # AIå¿œç­”ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
        node << 'EOF'
        const { spawn } = require('child_process');
        const https = require('https');

        async function runGeminiResponse() {
          const issueTitle = process.env.ISSUE_TITLE;
          const issueBody = process.env.ISSUE_BODY;
          const issueNumber = process.env.ISSUE_NUMBER;
          const issueLabels = process.env.ISSUE_LABELS || '';

          console.log(`Processing issue #${issueNumber}: ${issueTitle}`);

          // å•é¡Œåˆ†é¡
          const category = classifyIssue(issueTitle, issueBody, issueLabels);
          console.log(`Classified as: ${category}`);

          // Gemini ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
          const prompt = createPrompt(category, issueTitle, issueBody);

          try {
            // Gemini CLIå®Ÿè¡Œ
            const geminiResponse = await runGemini(prompt);
            console.log('Gemini response received');

            // GitHub APIã§ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿
            await postToGitHub(geminiResponse, issueNumber, category);
            console.log('Response posted successfully');

          } catch (error) {
            console.error('Error:', error);
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¿œç­”
            await postFallbackResponse(issueNumber, category);
          }
        }

        function classifyIssue(title, body, labels) {
          const text = (title + ' ' + body + ' ' + labels).toLowerCase();
          
          if (text.includes('ãƒã‚°') || text.includes('ã‚¨ãƒ©ãƒ¼') || 
              text.includes('å‹•ã‹ãªã„') || text.includes('bug') || 
              text.includes('error') || labels.includes('bug')) {
            return 'bug';
          } else if (text.includes('æ©Ÿèƒ½') || text.includes('è¿½åŠ ') || 
                     text.includes('æ”¹å–„') || text.includes('feature') || 
                     text.includes('enhancement') || labels.includes('enhancement')) {
            return 'feature';
          } else if (text.includes('è³ªå•') || text.includes('ä½¿ã„æ–¹') || 
                     text.includes('question') || text.includes('how') || 
                     labels.includes('question')) {
            return 'question';
          } else {
            return 'general';
          }
        }

        function createPrompt(category, title, body) {
          const basePrompt = `ã‚ãªãŸã¯å£è…”æ©Ÿèƒ½ä½ä¸‹ç—‡è¨ºæ–­ãƒ»ç®¡ç†ã‚¢ãƒ—ãƒªã®ã‚µãƒãƒ¼ãƒˆAIã§ã™ã€‚

Issueåˆ†é¡: ${category}
ã‚¿ã‚¤ãƒˆãƒ«: ${title}
å†…å®¹: ${body}

ä»¥ä¸‹ã®JSONå½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ï¼š
{
  "response": "GitHubã‚³ãƒ¡ãƒ³ãƒˆç”¨ã®Markdownå½¢å¼å›ç­”",
  "priority": "low|medium|high",
  "action_required": "å¿…è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³",
  "estimated_time": "å¯¾å¿œäºˆæƒ³æ™‚é–“"
}

åŒ»ç™‚å¾“äº‹è€…å‘ã‘ã‚¢ãƒ—ãƒªãªã®ã§ã€å°‚é–€æ€§ã¨ä¿¡é ¼æ€§ã‚’é‡è¦–ã—ãŸå›ç­”ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚`;

          return basePrompt;
        }

        function runGemini(prompt) {
          return new Promise((resolve, reject) => {
            const gemini = spawn('gemini', ['-p', prompt], {
              stdio: ['pipe', 'pipe', 'pipe'],
              env: { ...process.env }
            });

            let output = '';
            let error = '';

            gemini.stdout.on('data', (data) => {
              output += data.toString();
            });

            gemini.stderr.on('data', (data) => {
              error += data.toString();
            });

            gemini.on('close', (code) => {
              if (code === 0) {
                resolve(output);
              } else {
                reject(new Error(`Gemini CLI failed: ${error}`));
              }
            });

            // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ5åˆ†ï¼‰
            setTimeout(() => {
              gemini.kill();
              reject(new Error('Gemini CLI timeout'));
            }, 300000);
          });
        }

        async function postToGitHub(geminiOutput, issueNumber, category) {
          let response;
          
          try {
            // JSONéƒ¨åˆ†ã‚’æŠ½å‡º
            const jsonMatch = geminiOutput.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              const aiResponse = JSON.parse(jsonMatch[0]);
              response = formatResponse(aiResponse, category);
            } else {
              throw new Error('No JSON found in response');
            }
          } catch (parseError) {
            console.warn('JSON parse failed, using fallback');
            response = formatFallbackResponse(geminiOutput, category);
          }

          // GitHub APIæŠ•ç¨¿
          await makeGitHubRequest(issueNumber, response);
        }

        function formatResponse(aiResponse, category) {
          const categoryEmoji = {
            bug: 'ğŸ›',
            feature: 'âœ¨', 
            question: 'â“',
            general: 'ğŸ“'
          };

          return `## ${categoryEmoji[category]} AIè‡ªå‹•å¿œç­”

${aiResponse.response}

### ğŸ“Š åˆ†æçµæœ
- **å„ªå…ˆåº¦**: ${aiResponse.priority}
- **å¿…è¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**: ${aiResponse.action_required}
- **äºˆæƒ³å¯¾å¿œæ™‚é–“**: ${aiResponse.estimated_time}

---

### ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
é–‹ç™ºãƒãƒ¼ãƒ ãŒè©³ç´°ã‚’ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦è¿½åŠ æƒ…å ±ã‚’ãŠä¼ãˆã—ã¾ã™ã€‚

ç·Šæ€¥ã®å ´åˆã¯ã€Issueæœ¬æ–‡ã« **ã€Œç·Šæ€¥ã€** ã‚’è¿½è¨˜ã—ã¦ãã ã•ã„ã€‚

---
<sub>ğŸ¤– ã“ã®å¿œç­”ã¯Gemini AIï¼ˆç„¡æ–™æ ï¼‰ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ | å‡¦ç†æ™‚åˆ»: ${new Date().toLocaleString('ja-JP', {timeZone: 'Asia/Tokyo'})}</sub>`;
        }

        function formatFallbackResponse(rawOutput, category) {
          const categoryResponses = {
            bug: `## ğŸ› ãƒã‚°å ±å‘Šã¸ã®è‡ªå‹•å¿œç­”

ãŠå¿™ã—ã„ä¸­ã€ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆã‚’ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚

### åˆæœŸå¯¾å¿œæ‰‹é †
1. **ãƒ–ãƒ©ã‚¦ã‚¶å†èª­ã¿è¾¼ã¿**ï¼ˆCtrl+F5ï¼‰ã‚’ãŠè©¦ã—ãã ã•ã„
2. **åˆ¥ãƒ–ãƒ©ã‚¦ã‚¶**ã§ã®å‹•ä½œç¢ºèªã‚’ãŠé¡˜ã„ã—ã¾ã™  
3. **é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«**ï¼ˆF12ï¼‰ã§ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¢ºèªã—ã¦ãã ã•ã„

é–‹ç™ºãƒãƒ¼ãƒ ãŒ24æ™‚é–“ä»¥å†…ã«è©³ç´°èª¿æŸ»ã„ãŸã—ã¾ã™ã€‚`,

            feature: `## âœ¨ æ©Ÿèƒ½è¦æœ›ã¸ã®è‡ªå‹•å¿œç­”

ç´ æ™´ã‚‰ã—ã„ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼

### æ¤œè¨ãƒ—ãƒ­ã‚»ã‚¹
- æ—¢å­˜æ©Ÿèƒ½ã¨ã®é‡è¤‡ç¢ºèª
- æŠ€è¡“çš„å®Ÿè£…å¯èƒ½æ€§ã®è©•ä¾¡
- é–‹ç™ºè¨ˆç”»ã¸ã®çµ„ã¿è¾¼ã¿æ¤œè¨

æ¤œè¨çµæœã¯1é€±é–“ä»¥å†…ã«ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã€‚`,

            question: `## â“ ã”è³ªå•ã¸ã®è‡ªå‹•å¿œç­”

ã”è³ªå•ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚

ã¾ãšã¯[README.md](./README.md)ã‚„[éå»ã®Q&A](../../issues?q=label%3Aquestion)ã‚’ã”ç¢ºèªãã ã•ã„ã€‚

è§£æ±ºã—ãªã„å ´åˆã¯è©³ç´°ã‚µãƒãƒ¼ãƒˆã„ãŸã—ã¾ã™ã€‚`,

            general: `## ğŸ“ ãŠå•ã„åˆã‚ã›ã¸ã®è‡ªå‹•å¿œç­”

ãŠå•ã„åˆã‚ã›ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚

å†…å®¹ã‚’ç¢ºèªã—ã€é©åˆ‡ãªæ‹…å½“è€…ãŒå›ç­”ã„ãŸã—ã¾ã™ã€‚`
          };

          return categoryResponses[category] + `

---
<sub>ğŸ¤– AIè‡ªå‹•å¿œç­”ã‚·ã‚¹ãƒ†ãƒ  | ${new Date().toLocaleString('ja-JP', {timeZone: 'Asia/Tokyo'})}</sub>`;
        }

        async function postFallbackResponse(issueNumber, category) {
          const response = formatFallbackResponse('', category);
          await makeGitHubRequest(issueNumber, response);
        }

        function makeGitHubRequest(issueNumber, body) {
          return new Promise((resolve, reject) => {
            const postData = JSON.stringify({ body });

            const options = {
              hostname: 'api.github.com',
              port: 443,
              path: `/repos/${process.env.GITHUB_REPOSITORY}/issues/${issueNumber}/comments`,
              method: 'POST',
              headers: {
                'Authorization': `token ${process.env.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData),
                'User-Agent': 'Gemini-AI-Bot'
              }
            };

            const req = https.request(options, (res) => {
              if (res.statusCode >= 200 && res.statusCode < 300) {
                console.log(`âœ… Response posted to issue #${issueNumber}`);
                resolve();
              } else {
                console.error(`âŒ GitHub API error: ${res.statusCode}`);
                reject(new Error(`HTTP ${res.statusCode}`));
              }
            });

            req.on('error', (e) => {
              console.error(`âŒ Request error: ${e.message}`);
              reject(e);
            });

            req.write(postData);
            req.end();
          });
        }

        // ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
        runGeminiResponse().catch(console.error);
        EOF